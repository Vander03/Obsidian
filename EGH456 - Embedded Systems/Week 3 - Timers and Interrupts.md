
## 1 Timers 
Chapter 13,16, Microcontroller Datasheet
### 1.1 Useful for:
 - Respond or generate interrupts
 - Triggering ADC events
 - Generating signals (PWM)
 - Handling/Counting input signals (GPIO, encoders, data, etc)

**Graphical Representation:**
![[Pasted image 20250314184612.png|500]]

### 1.2 Available Clocks
#### 1.2.1 System Clocks (SysClk)
- Distributed by CPU
- Based on clock source and divisor factor

#### 1.2.2 Precision Internal Oscillator (PIOSC)
- Enabled on power up
- 16MHz
- `SYSCTL_OSC_INT`
- Internal can be cheap, using external allows us to use a timer of our choice on the board
#### 1.2.3 Main Oscillator (MOSC)
- External XTAL 5-25MHz
- `SYSCTL_OSC_MAIN`

#### 1.2.4 Phase Locked Loop (PLL)
- Locks in the phase of the input signal and allows you to upscale the frequency
- Disabled by default when powered on
- Generates clock freq faster than source clock (POISC or MOSC)
- Two output frequencies: 320 or 480MHz

![[Pasted image 20250314185119.png]]

### 1.3 EXAMPLE: Setting System Clock
SELECT oscillator source, system clock source and desired frequency
Example: Configure the system clock to be 40 MHz with a 320-MHz PLL setting using the 16-MHz internal oscillator.
```C
ui32clockFreq = SysCtlClockFreqSet(SYSCTL_OSC_INT | SYSCTL_USE_PLL |
SYSCTL_CFG_VCO_320, 40000000); // returns actual sys clk frequency in Hz or 0 if the value could not be changed, used to convert desired to actual frequency
```

### 1.4 Enabling the Timer
```C
uint32_t ui32SysClock;
ui32SysClock = SysCtlClockFreqSet((SYSCTL_XTAL_25MHZ | SYSCTL_OSC_MAIN | SYSCTL_USE_PLL | SYSCTL_CFG_VCO_480), 120000000);
// Run from the PLL at 120 MHz.
SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER0); // Enable the Timer 0 Module.
TimerConfigure(TIMER0_BASE, TIMER_CFG_PERIODIC); // Configure the timer in periodic mode and full width (32 bits).
TimerLoadSet(TIMER0_BASE, TIMER_A, ui32SysClock); // Load the timer value
TimerEnable(TIMER0_BASE, TIMER_A); // Enable the timer.
```

### 1.5 TImer Module
**Interval Load** - name for top value (how much it counts up to)
**RTC - real time counter mode** - sets it to 1s
![[Pasted image 20250314185402.png]]
![[Pasted image 20250317201148.png]]

### 1.6 Edge Count Mode
Counts the edges of an input
![[Pasted image 20250318174319.png|500]]
 
### 1.7 Watchdog Timer
Is there to ensure the system can regain control if it gets locked up. 
**Need to feed the watchdog in loops otherwise it will reset the system**
Consists of 2 timers with 32but down counter and programmable load register. Has configurable interrupt with optional Non-Maskable Interrupt (NMI)
- One module is closed via system clock
- The other is clocked using an alternate clock

### 1.8 Hibernation Module
- Puts CPU and pheripherals into idle turning off their power. Can be woken up by an external source or built in clock. Also includes a calendar function to wake it up on a date.
## 2 Exceptions and Interrupts
Chapter 2, Microcontroller Datasheet
Asynchronous events are Independent of the CPU, includes
- External events (such as switch actions)
- Events that determine when an input device has data available
- When an input device needs data

### 2.1 Graphical Models of Software
![[Pasted image 20250317201937.png|400]]
- Flow Charts
	- Useful for small sections of code, functions or subroutines
- State Machines
	- For event drive, object models, language recognition
	- Pros
		- Easy to develop code for
		- Can be formally optimised
		- Concurrency can be depicted using multiple machines
		- One thread could be executing while others wait for events
	- Cons
		- Cannot describe structure of modules
		- Does not show how to break down into subroutines
		- Communication between SM can be difficult to depict
- Data flow diagrams
- Message flow diagrams

### 2.2 Exceptions
Any condition that needs to halt the normal sequential flow of instruct execution. Categories include: Reset, system, faults and interrupt (IRQ)

#### 2.2.1 Exception vs Interrupt
Exceptions are synchronous events generated when processor detects any predefined condition while executing instructions. (Faults, Traps and aborts)

Interrupts are a subset of exceptions and are handled by the processor after finishing current instruction. They are asynchronous events that are normally generated by hardware (I/O), not in sync with processor instruction execution.

Interrupts inform the program of some external event and breaks the execution flow.

Each exception has:
- An exception number 0-255
- A priority level
- An exception handler routine
- An entry into the vector table (program address of associated handler routine, by default stored at address 0 and cab be relocated by changing the vector table offset register `VTABLE`)

### 2.3 Exception States
![[Pasted image 20250317202825.png]]

### 2.4 Exception Tables
![[Pasted image 20250317202900.png]]

### 2.5 Exception Handlers (ISR)
![[Pasted image 20250317203010.png]]

**Exception Processing**:
![[Pasted image 20250317203042.png]]

### 2.6 Thread and Handler Modes
![[Pasted image 20250318191329.png]]
Mode is destinguished by the **Program Status Register (PSR)** holds the current exception type:
- 0 bits in thread mode
- Nonezero in handler mode

#### 2.6.1 Thread Mode
- During execution of main program or thread (could use MSP or PSP)
- Always entered out of reset

#### 2.6.2 Handler Mode
- During the execution of a handler (uses MSP)
- When finished returns to thread mode

### 2.7 Interrupt Latency
Note that exception handling are not free, there is inherent latency when swapping program memory out and others in

![[Pasted image 20250318191908.png|500]]

#### 2.7.1 Tail-Chaining
Exception handling optimisation. Automatically doesnt unstack if another ISR follows.

![[Pasted image 20250318192054.png|500]]